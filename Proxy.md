###### tags: `Design Pattern` 
# Proxy 
> Das Muster
> ![](https://i.imgur.com/gBFwn55.png)

## Remote Proxy
![](https://i.imgur.com/Bw4YsvT.png)

`Client` sends Request
```
Client 
    '--request--> proxy 
                     '--request--> RealSubject
```

`RealSubject` receives the Request and returns the response to `Client`
```
RealSubject
    '--response--> proxy 
                    '--response--> Client
```
- The proxy acts as a local representative for an object that live in a **different JVM** 

### [Example For Remote Proxy](https://fjp.at/design-patterns/proxy)

## Virtual Proxy

**The Virtual Proxy often defers the creation of the object until it is needed.**  
![](https://i.imgur.com/nEo580y.png)  
 

#### An example downloading a CD cover using Virtual Proxy

[sourceCode](https://github.com/bethrobson/Head-First-Design-Patterns/tree/master/src/headfirst/designpatterns/proxy/virtualproxy)

[Java Icon](https://docs.oracle.com/javase/tutorial/uiswing/components/icon.html)

![](https://i.imgur.com/v7ZVpWQ.png)  

> How virtual proxy of the example working with illustration ?
> --- 
>>`ImageProxy` will initialize a instance of `ImageIncon` and use it to get image from the `Server`
>>![](https://i.imgur.com/dsTQKGq.png)  
>>> When instance of `ImageIcon` gets a complete image from the `Server` then it would display it directly on client's screen without `ImageProxy`'s help  
>>> ![](https://i.imgur.com/9l7FU9x.png)  


 
```java
import java.net.*;     // thread
import java.awt.*;       
import javax.swing.*;  // Icon

class ImageProxy implements Icon 
{ 
    /** 
     * <p> Create A instance of realSubject.</p>
     */
    volatile ImageIcon imageIcon;
    
    
    final URL imageURL;
    
    /**
     *  For downloading the Image
     */
    Thread retrievalThread;
    
    boolean retrieving = false;

    /**
     * @param url 
     * where the image can be downloded
     */
    public ImageProxy(URL url) { imageURL = url; }

    public int getIconWidth()  {/*skip*/}
    public int getIconHeight() {/*skip*/}

    synchronized void setImageIcon(ImageIcon imageIcon)
    {
    //To protect reads (volatile) 
    //     and weites (syncronized setter method)
        this.imageIcon = imageIcon;

    }

    // To paint the icon on the screen
    public void paintIcon(final Component c, 
                  Graphics  g, int x,  int y)
    {
        if (imageIcon != null) 
        {
        //** Display Image directly
        //          Using realSubject
            imageIcon.paintIcon(c, g, x, y);
        } 
        else 
        {
            g.drawString(
                "Loading album cover, please wait...",
                x+300, y+190);
            if (!retrieving) 
            {
                retrieving = true;
                retrievalThread = new Thread(new Runnable() 
                {
                    public void run() 
                    {
                        try
                        {// Using a instance of ImageIcon
                         //    NOT instance of ImageProx itself
                            setImageIcon(new ImageIcon
                            (imageURL, "Album Cover"));
                            c.repaint();
                        }
                        catch (Exception e) 
                        {
                            e.printStackTrace();
                        }
                    }
                });

                /* using Lambda
                retrievalThread = new Thread(() -> {
                        try 
                        {
                            setImageIcon(new ImageIcon
                            (imageURL, 
                            "Album Cover"));
                            c.repaint();
                        } 
                        catch (Exception e) {
                            e.printStackTrace();
                        }
                });
                */
                
                // starting to download the image icon
                retrievalThread.start();
            }
        }
    }
}
```


## Protect Proxy (from the java API's dynamic Proxy)

[SourceCode](https://github.com/bethrobson/Head-First-Design-Patterns/tree/master/src/headfirst/designpatterns/proxy/javaproxy)

The Difference of Protect Proxy from the other proxies is
- The proxy will be generated by Java itself and implements the entire Subject interface, so all we need to handle is supply a `handler` that knows what to do when a method is called on it

> Pattern
> : ![](https://i.imgur.com/DaQEktc.png)

Steps
1. InvocationHandlers(concrete ones and interface one) implement the behaviour of the proxy
2. Wrap the objects of InvocationHandler with the appropriate proxy (e.g. InvocationHandler_2 and InvocationHandler_1 ...)
3. Creating invoke() in Concrete InvocationHandler
    ![](https://i.imgur.com/hF5ozyX.png)
4. Creating the Proxy class and instantiating the Proxy object in class InvocationHandler
    ![](https://i.imgur.com/ixlMgOL.png)


### [Other Proxies](http://corrupt003-design-pattern.blogspot.com/2016/10/proxy-pattern.html)

