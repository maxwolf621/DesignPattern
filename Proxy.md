# Proxy 

###### tags: `Design Pattern`

> Pattern
> : ![](https://i.imgur.com/gBFwn55.png)


## Remote Proxy
![](https://i.imgur.com/Bw4YsvT.png)

Client sends Request
```
client 
    '-- request() -> proxy 
                       '-- request() -> RealSubject
```

RealSubject accept the Request and return result to client
```
RealSubject
    '--- resut -> proxy 
                   '-----> result -> client
```


> The proxy acts as a local representative for an object that live in a **different JVM** 



## Virtual Proxy
![](https://i.imgur.com/nEo580y.png)
> The Virtual Proxy often defers the creation of the object until it is needed. 
 

### An example downloading a CD cover using Virtual Proxy

[sourceCode](https://github.com/bethrobson/Head-First-Design-Patterns/tree/master/src/headfirst/designpatterns/proxy/virtualproxy)
[Java Icon](https://docs.oracle.com/javase/tutorial/uiswing/components/icon.html)

![](https://i.imgur.com/v7ZVpWQ.png)


> How virtual proxy of the example working with illustration 
> : 1. ImageProxy will initialize a instance of ImageIncon using it to get image
![](https://i.imgur.com/dsTQKGq.png)
> :  2. When instance of ImageIcon gets a complete image from the server then it would display it directly on client's screen without ImageProxy helping
![](https://i.imgur.com/9l7FU9x.png)


 
```java=
import java.net.*;     // thread
import java.awt.*;       
import javax.swing.*;  // Icon

class ImageProxy implements Icon 
{ 
 
    // 1. Create A instance of realSubject.
    // 2. We use it to display the image 
    //     on Client Screen 
    //           instead of using Imageproxy
    volatile ImageIcon imageIcon;
    
    final URL imageURL;
    Thread retrievalThread;
    boolean retrieving = false;

    // Constructor : get URL 
    //     where the image can be downloded
    public ImageProxy(URL url) { imageURL = url; }

    public int getIconWidth()  {/*skip*/}
    public int getIconHeight() {/*skip*/}

    synchronized void setImageIcon(ImageIcon imageIcon)
    {
    //** to protect reads (volatile) 
    //     and weites (syncronized setter method)
        this.imageIcon = imageIcon;

    }

    // To paint the icon on the screen
    public void paintIcon(final Component c, 
                  Graphics  g, int x,  int y)
    {
        if (imageIcon != null) 
        {
        //** Display Image directly
        //          Using realSubject
            imageIcon.paintIcon(c, g, x, y);
        } 
        else 
        {
            g.drawString(
                "Loading album cover, please wait...",
                x+300, y+190);
            if (!retrieving) 
            {
                retrieving = true;
                retrievalThread = new Thread(new Runnable() 
                {
                    public void run() 
                    {
                        try
                        {// Using a instance of ImageIcon
                         //    NOT instance of ImageProx itself
                            setImageIcon(new ImageIcon
                            (imageURL, "Album Cover"));
                            c.repaint();
                        }
                        catch (Exception e) 
                        {
                            e.printStackTrace();
                        }
                    }
                });

                /* using Lambda
                retrievalThread = new Thread(() -> {
                        try 
                        {
                            setImageIcon(new ImageIcon
                            (imageURL, 
                            "Album Cover"));
                            c.repaint();
                        } 
                        catch (Exception e) {
                            e.printStackTrace();
                        }
                });
                */
                
                // starting to download the image icon
                retrievalThread.start();
            }
        }
    }
}
```


## Protect Proxy (from the java API's dynamic Proxy)

[SourceCode](https://github.com/bethrobson/Head-First-Design-Patterns/tree/master/src/headfirst/designpatterns/proxy/javaproxy)

The Difference of Protect Proxy from the above proxies 
- The proxy will be generated by Java itself and implements the entire Subject interface, so all we need to handle is supply a handler that knows what to do when a method is called on it

> Pattern
> : ![](https://i.imgur.com/DaQEktc.png)

Steps
1. InvocationHandlers(concrete ones and interface one) implement the behaviour of the proxy
2. Wrap the objects of InvocationHandler with the appropriate proxy (e.g. InvocationHandler_2 and InvocationHandler_1 ...)
3. Creating invoke() in Concrete InvocationHandler
    ![](https://i.imgur.com/hF5ozyX.png)
4. Creating the Proxy class and instantiating the Proxy object in class InvocationHandler
    ![](https://i.imgur.com/ixlMgOL.png)


## Other Proxies

[REF](http://corrupt003-design-pattern.blogspot.com/2016/10/proxy-pattern.html)